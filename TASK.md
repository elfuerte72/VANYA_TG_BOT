## Задачи для разработки Telegram-бота расчёта КБЖУ

Ниже приведён подробный список задач, разбитых по этапам и модулям. Каждая задача — самостоятельная единица работы для разработчика.

---

### 1. Подготовительный этап

1.1. **Инициализация репозитория и окружения**
- Создать Git-репозиторий.
- Настроить менеджер пакетов (Poetry/PDM) и файл `pyproject.toml`.
- Добавить `.gitignore` для исключения виртуальных окружений, логов, файла базы данных.

1.2. **Конфигурация окружения**
- Создать шаблон `.env.example` с полями: `BOT_TOKEN`, `OPENAI_API_KEY`, `DB_PATH`, `LOG_LEVEL`.
- Настроить загрузку переменных из `.env` через `python-dotenv`.

1.3. **Структура проекта**
- Спроектировать файловую структуру:
  - `bot/` — модули бота (handlers, services, utils).
  - `data/` — файл базы данных `users.db`.
  - `tests/` — тесты.
  - `logs/` — файлы логов.
  - `config/` — конфигурационные файлы.

---

### 2. Проектирование и архитектура

2.1. **Определение слоёв приложения**
- `handlers/` — обработчики команд и сообщений.
- `services/` — бизнес-логика (проверка подписки, расчёт КБЖУ, генерация плана).
- `repository/` — доступ к БД (CRUD для пользователей).
- `utils/` — вспомогательные функции (валидация, конвертации).
- `core/` — общие настройки (логирование, подключение к Telegram API и OpenAI API).

2.2. **Схема БД**
- Таблица `users`:
  - `id` INTEGER PRIMARY KEY AUTOINCREMENT
  - `telegram_id` BIGINT UNIQUE NOT NULL
  - `calculated` BOOLEAN DEFAULT FALSE
  - `gender` TEXT
  - `age` INTEGER
  - `height` INTEGER
  - `weight` REAL
  - `activity_factor` REAL
  - `calculated_at` TIMESTAMP
- Убедиться в шифровании файла БД (использовать SQLCipher или аналог).

2.3. **Диаграмма состояний диалога**
- START → CHECK_SUBSCRIPTION → STATE: `await_gender` → `await_age` → `await_height` → `await_weight` → `await_activity` → CONFIRMATION → CALCULATION → FINISH.
- Определить состояния Finite State Machine (aiogram FSM).

---

### 3. Реализация функциональности бота

#### 3.1 Проверка доступа

3.1.1. **Метод проверки подписки**
- Реализовать вызов Telegram API для проверки, состоит ли пользователь в заданном канале.
- Обработать возможные ошибки (бот не администратор, приватный канал).

3.1.2. **Логика отказа**
- При неуспешной проверке отправлять сообщение с инструкцией подписаться.
- Блокировать дальнейшие сообщения до подтверждения подписки.

#### 3.2 Процедура единожды расчёта

3.2.1. **Фиксация флага расчёта**
- После первого расчёта устанавливать `calculated = true`.
- При последующих обращениях проверять этот флаг и отправлять уведомление.

3.2.2. **Обновление модели**
- При изменении параметров до расчёта сохранять их в БД временно.

#### 3.3 Диалоговый сценарий и сбор параметров

3.3.1. **Команда `/start`**
- Реализовать хэндлер для запуска FSM.
- Кнопка "▶️ Запустить расчёт" для интерактивного старта.

3.3.2. **Сбор данных**
- Хэндлеры для каждого параметра: пол, возраст, рост, вес, уровень активности.
- Валидация введённых значений (числа, диапазоны).
- Локализация вариантов выбора пола и активности.

3.3.3. **Подтверждение данных**
- Отправить сводную карточку с введёнными параметрами.
- Кнопки «Изменить» (возврат к нужному шагу) и «Подтвердить».

#### 3.4 Реализация алгоритма расчёта

3.4.1. **Функция расчёта BMR**
- Вынести в `services/calculation.py` функции:
  - `calc_bmr_male(weight, height, age)`
  - `calc_bmr_female(weight, height, age)`

3.4.2. **Учет активности**
- Применить коэффициент активности:
  - Низкий — 1.2
  - Средний — 1.55
  - Высокий — 1.725
- Значение по умолчанию — 1.55.

3.4.3. **Распределение приёмов пищи**
- В зависимости от `calories`:
  - `< 2000` — 3 приёма.
  - `>= 2000` — 4 приёма.

3.4.4. **Расчёт макронутриентов**
- Доли макро (пока статично):
  - Белки 20% калорий → граммы: `calories * 0.20 / 4`.
  - Жиры 25% калорий → граммы: `calories * 0.25 / 9`.
  - Углеводы 55% калорий → граммы: `calories * 0.55 / 4`.

#### 3.5 Формирование и отправка результата

3.5.1. **Шаблон сообщения**
- Использовать MarkdownV2 или HTML для форматирования.
- Включить секцию:
  - **Ккал/сутки:** `XXXXX`
  - **Белки:** `XX г` и т. д.

3.5.2. **План питания**
- Разбивка КБЖУ по приёмам с динамическими кнопками или без.
- Примерную таблицу цифр без конкретных продуктов.

3.5.3. **Опциональный комментарий**
- Шаблон для целей похудения/набор массы.
- Возможность расширения в будущем.

---

### 4. Нефункциональные задачи

4.1. **Логирование**
- Настроить `logging` в `core/logger.py`.
- Логи в файл `logs/bot.log` с ротацией (TimteRotatingFileHandler).
- Логировать ошибки, входящие данные, ключевые шаги.

4.2. **Обработка ошибок и устойчивость**
- Глобальный хэндлер исключений (aiogram `on_error`).
- Игнорирование повторных запросов от одного юзера при активном FSM.

4.3. **Безопасность**
- Хранение токенов только в окружении.
- Шифрование SQLite (SQLCipher) или альтернативное решение.

4.4. **Производительность**
- Не более 3 сек отклика на любой запрос.
- Кеширование результатов расчёта для быстрого чтения.

---

### 5. Тестирование и CI/CD

5.1. **Модульные тесты**
- Тесты для функций расчёта BMR и макродолей.
- Тесты для FSM-состояний и хэндлеров (pytest + aiogram тестовые утилиты).

5.2. **Интеграционные тесты**
- Проверка полного сценария `/start` → расчёт → повторный запрос.

5.3. **Настройка CI**
- GitHub Actions:
  - `lint` (flake8/isort).
  - `test` (pytest).
  - `build` (проверка сборки Poetry).

5.4. **Code Review**
- Настроить правила ветвления: `main`, `develop`, `feature/*`.
- Pull Request шаблон с чек-листом.

---

### 6. Деплой и мониторинг

6.1. **Подготовка контейнера**
- Dockerfile для бота.
- docker-compose с сервисом `bot` и volume для БД.

6.2. **Развёртывание**
- Выкатка на VPS или Kubernetes (по согласованию).
- Настройка systemd / Deployment манифестов.

6.3. **Мониторинг и алерты**
- Простая проверка статуса (`healthcheck`) раз в минуту.
- Логи в централизованную систему (опционально).
- Уведомление в Telegram администратора при падении.

---

*Конец списка задач — можете распределять между командой и оценивать время выполнения.*
